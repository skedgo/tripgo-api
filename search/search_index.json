{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"TripGo API The TripGo API allows you to plan door-to-door trips using a large variety of public and private transport. It integrates real-time information and, for selected providers, allows users to book and pay for transport. Getting started 1. Getting an API key Get an API key . You can try it out for free for as long as you like, as long as you stay below a threshold of API calls - no credit card required. For limits on the free tier and pricing, see the SkedGo website . It may take up to 5 minutes for your key to be active. Once you have an API key, send it along with every request as the X-TripGo-Key header. 2. Make a request Our API can do a lot more than just directions , but if that is what you are interested in, then try something like: curl 'https://api.tripgo.com/v1/routing.json?from=(-33.859,151.207)&to=(-33.863,151.208)&departAfter=1532799914&modes=wa_wal&v=11&locale=en' -H 'Accept: application/json' --compressed -H \"X-TripGo-Key: $tripgoKey\" -g or curl 'https://api.tripgo.com/v1/routing.json?from=(-33.859,151.207)&to=(-33.891,151.209)&modes=pt_pub&v=11&locale=en' -H 'Accept: application/json' --compressed -H \"X-TripGo-Key: $tripgoKey\" -g Keep in mind that this API is optimised to return a large number of trip results while maintaining small response sizes. This has a number of complications. Notably, to get a trip's segments you need to combine the segment references with the segment templates. This is explained further in the F.A.Q. . 3. Where to go from here? If you're an app developer, take a look at our open source TripKit SDKs for iOS, macOS , and Android . If you're a web developer, take a look at our React SDK , or check out our Leaflet Plugin (see Demo ). If you're a backend developer, dive into the API specs , which are available in OpenAPI (formerly Swagger) format. If you know how to debug a web app, look at the network activity for our web app to get an idea of which API calls to use when. (Filter for \"satapp\".) To talk to us and other developers using our API, join our Slack team on this page .","title":"Getting Started"},{"location":"#tripgo-api","text":"The TripGo API allows you to plan door-to-door trips using a large variety of public and private transport. It integrates real-time information and, for selected providers, allows users to book and pay for transport.","title":"TripGo API"},{"location":"#getting-started","text":"","title":"Getting started"},{"location":"#1-getting-an-api-key","text":"Get an API key . You can try it out for free for as long as you like, as long as you stay below a threshold of API calls - no credit card required. For limits on the free tier and pricing, see the SkedGo website . It may take up to 5 minutes for your key to be active. Once you have an API key, send it along with every request as the X-TripGo-Key header.","title":"1. Getting an API key"},{"location":"#2-make-a-request","text":"Our API can do a lot more than just directions , but if that is what you are interested in, then try something like: curl 'https://api.tripgo.com/v1/routing.json?from=(-33.859,151.207)&to=(-33.863,151.208)&departAfter=1532799914&modes=wa_wal&v=11&locale=en' -H 'Accept: application/json' --compressed -H \"X-TripGo-Key: $tripgoKey\" -g or curl 'https://api.tripgo.com/v1/routing.json?from=(-33.859,151.207)&to=(-33.891,151.209)&modes=pt_pub&v=11&locale=en' -H 'Accept: application/json' --compressed -H \"X-TripGo-Key: $tripgoKey\" -g Keep in mind that this API is optimised to return a large number of trip results while maintaining small response sizes. This has a number of complications. Notably, to get a trip's segments you need to combine the segment references with the segment templates. This is explained further in the F.A.Q. .","title":"2. Make a request"},{"location":"#3-where-to-go-from-here","text":"If you're an app developer, take a look at our open source TripKit SDKs for iOS, macOS , and Android . If you're a web developer, take a look at our React SDK , or check out our Leaflet Plugin (see Demo ). If you're a backend developer, dive into the API specs , which are available in OpenAPI (formerly Swagger) format. If you know how to debug a web app, look at the network activity for our web app to get an idea of which API calls to use when. (Filter for \"satapp\".) To talk to us and other developers using our API, join our Slack team on this page .","title":"3. Where to go from here?"},{"location":"extensions/","text":"Right after signing up, the API will serve results for regions and transport providers that publish their data as Open Data and which have already been connected to our system. The TripGo API can be extended in the following ways: Unlock transport modes, regions and real-time data from services that require you to first accept their terms or acquire API credentials. Add new transport modes through our TSP Connectors. Add new regions through our Region Connectors (coming soon). Regions Unlocking regions To get results for regions with providers that aren't using Open Data please get in touch with our team by mail or on Slack (by self-invite ). Rio de Janeiro (Brazil) \ud83c\udf0e Go to Fetransport Site and make sure you agree with the data terms. Contact us if you need help for this. Forward your confirmation mail to api@skedgo.com We will then unlock the region for your API key. Adding new regions To get results for regions that are not yet covered by the TripGo API, you as an API client can help us with the integration process to add a region of interest as follows: Collect all \"Minimum required data\" detailed below. Send the URLs where we could donwload the data from the sources to api@skedgo.com . For the cases where the data is not in a public accessible repository, please also pass on necessary contact information or access details. Wait until SkedGo processes all the information and updates the backend with the new region. This last process involves: - Configuring the region with the required data - Allocating cloud resources, including redunancy - Testing and verification of data quality and routing results - Once all tests pass, our data team will promote the new regions to our production servers For expected timing and pricing, please refer to our published price list . Minimum required data Name of the country and city or area which is going to be added. Coverage: The region's coverage area where the service is going to be provided, as a polygon or bounding rectangle. The most important city or cities from that area. URL(s) to the public transport timetables for that area in a standard data format that can be be consumed by our platform. A very important rule to follow, is to include data for every major public transport operator in the coverage area. Supported data formats are: - General Transit Feed Specification (GTFS) - NeTEx - TransXChange Country/region properties that configure our routing and API responses, including: - Currency - Timezone - Default language - Preferred distance unit (metric/imperial) - Drive on left / right - Taxi cost for that area (see TSP connectors below) - Average fuel cost Road and footpath information is being consumed from OpenStreetMap , so there is no need to provide that. Optional data More cities to be displayed on the map: Each of them should have a default position. Public holidays information: Country default ones could be loaded from global repositories but regional or local ones could be added. Public transport real-time data, using one of the following standards: - GTFS-Realtime - Siri Car park information Transport service providers (see TSP connectors below) Traffic alerts (see \"info\" connectors below) Customisations Rules for when bicycles are allowed on public transport and on which types of public transport. This is useful when this data is not provided as part of the public transport sources. Icon customisation for specific transports or services. Icon customisation for specific public transport nodes. Public transport fare calculations, see our published price list . Transport providers Unlocking transport modes To get results for providers who aren't using Open Data, follow the instructions for the provider below. If you want to use a provider that hasn't yet been connected to our system, please get in touch with our team by mail or on Slack (by self-invite ). BlaBlaCar \ud83c\udf0d Integrations : Routing, Real-time Read the terms of use of BlaBlaCar's API and make sure you comply with them in your app. Sign up to BlaBlaCar's API . Enter your BlaBlaCar auth key in your application credentials . BlaBlaCar results will start coming through the TripGo API for your API key (after at most 5 minutes). GoGet \ud83c\udde6\ud83c\uddfa Integrations : Locations, Routing, Real-time Get in touch with GoGet 's sales team and get access to their API. Enter your GoGet ConsumerKey and GoGet ConsumerSecret in your application credentials . GoGet results will start coming through the TripGo API for your API key (after at most 5 minutes). Lyft \ud83c\uddfa\ud83c\uddf8 Integrations : Routing, Real-time, Bookings Read the terms of use of Lyft's API and make sure you comply with them in your app. Sign up to Lyft's API . Enter your Lyft Client ID and Lyft Client Secret in your application credentials . Lyft results will start coming through the TripGo API for your API key (after at most 5 minutes). Ola \ud83c\uddee\ud83c\uddf3 \ud83c\udde6\ud83c\uddfa \ud83c\uddf3\ud83c\uddff \ud83c\uddec\ud83c\udde7 Integrations : Routing, Real-time Get in touch with Ola 's sales team and get access to their API. Enter your OLA ApiKey in your application credentials . Ola results will start coming through the TripGo API for your API key (after at most 5 minutes). Unlocking public transport real-time data To get real-time data for providers who aren't using Open Data, follow the instructions for the provider below. If you want to use a provider that hasn't yet been connected to our system, please get in touch with our team by mail or on Slack (by self-invite ). Chicago's CTA \ud83c\uddfa\ud83c\uddf8 Read the terms of use of CTA's API and make sure you comply with them in your app Sign up to CTA's API Enter your CTA key for Chicago in your application credentials . Real-time data for CTA for your TripGo API key will be enabled (after at most 5 minutes). STIB-MIVB in Brussels \ud83c\udf0e Read the terms of use of STIB-MIVB's open data platform and make sure you comply with them in your app Sign up to STIB-MIVB's API Enter your STIB-MIVB realtime api key in your application credentials . Real-time data for STIB-MIVB for your TripGo API key will be enabled (after at most 5 minutes). To get real-time data for providers who aren't using Open Data, follow the instructions for the provider below. If you want to use a provider that hasn't yet been connected to our system, please get in touch with our team by mail or on Slack (by self-invite ). Adding new providers: TSP connectors For TSPs that are not yet integrated into our platform, you can add them by: Implementing the corresponding API according to our API specs , and then Sending the URL of where you have deployed your implementation to api@skedgo.com . The process then involves a manual step (which we plan to automate) to add that to our list of TSP connectors and enable it. It will usually take 1 day after it is added to our list for results will then include the new TSP, with some exceptions like pod based share vehicles, which will take between 3 and 7 days. How does this work All TSP connector APIs share in common three endpoints: config : the list of endpoints that are implemented, similar to gbfs.json provider : the information about the provider, which may include links to mobile apps and deep links (with a pattern); and also the list of modes for the TSP coverage : a list of coverage areas of the provider, and for each area, it is possible to define available products and pricing rules Config endpoint allows our platform to understand what are the capabilities of the TSP integration of each connector. Provider information is what our platform will use to attribute results. This will be passed on with any API responses that include results from your TSP connector. Coverage will allow our platform to know in which areas (i.e., regions) the TSP will be enabled. Taxi and TNC For taxi and TNC providers we defined a Taxi API which allows you to: Add static pricing (in coverage endpoint), which will be shown as an estimate cost and used by our routing engine when creating trip alternatives. Provide real-time ETAs, which might differ by \"product\". Provide real-time costs estimations based on specific trip details. Enable in-app booking capabilities, so users can directly initiate the booking process through our platform. Shared bikes, scooters and cars For shared vehicles, such as bikes, scooters or cars, we support the GBFS standard with the addition of the shared endpoints mentioned above (except for config which is replaced by the standard gbfs.json ). This includes support for car-sharing, but be aware that this part of the standard is not finalised yet (as of February 2021). We also support GBFS sources with only one endpoint, for example just the free_bike_status.json endpoint. Additional data sources Unlocking real-time traffic To get real-time traffic information, you need to unlock one of the providers below. If you want to use a provider that hasn't yet been connected to our system, please get in touch with our team by mail or on Slack (by self-invite ). Live-Traffic from Google \ud83c\udf0e Read the terms of use of Google Maps and make sure you comply with them in your app - in particular, that you are using a Google Map. Sign up to the Google Maps Directions API Enter your Google Maps Directions API key in your application credentials . Car results leaving now will then come augmented with Google's drive time predictions through the TripGo API for your API key (after at most 5 minutes). Live-Traffic from TomTom \ud83c\udf0e Sign up to the TomTom Maps API , making sure you read the terms and comply with them - in particular, that you're not affiliated with a prohibited party and that you're using a TomTom or TomTom licenses map UI (e.g., Apple Maps). Enter your TomTom consumer API key and TomTom consumer secret in your application credentials . Car results leaving now will then come augmented with TomTom's drive time predictions through the TripGo API for your API key (after at most 5 minutes). Unlocking geocoding providers To get results from geocoding data for providers who aren't using Open Data when using geocoding.json endpoint, follow the instructions for the provider below. These providers will only apply for non auto-completion requests, except for What3Words ones, which can be used for both type of geocoding requests. If you want to use a provider that hasn't yet been connected to our system, please get in touch with our team by mail or on Slack (by self-invite ). Foursquare \ud83c\udf0e Read the Foursquare Terms of Use and make sure you comply with them in your app. Sign up to the Foursquare Developers Site Enter your Foursquare API key in your application credentials . Add allowFoursquare=true to your geocoding requests, and then geocoding results will then come augmented with Foursquare's API through the TripGo API for your API key (after at most 5 minutes). Google Places \ud83c\udf0e Read the Places API Policies and make sure you comply with them in your app - in particular, that you are using a Google Map. Sign up to the Google Places API Enter your Google Places API key in your application credentials . Add allowGoogle=true to your geocoding requests, and then geocoding results will then come augmented with Google Places's API through the TripGo API for your API key (after at most 5 minutes). What3Words \ud83c\udf0e Read the API Licence Agreement and make sure you comply with them in your app. Sign up to the What3Words API Enter your What 3 Words key in your application credentials . Add allowW3W=true to your geocoding requests, and then geocoding results will then come augmented with What3Words's API through the TripGo API for your API key (after at most 5 minutes). Yelp \ud83c\udf0e Read the Yelp Terms of Use and make sure you comply with them in your app. Sign up to the Yelp Developers Site Enter your Yelp API key in your application credentials . Add allowYelp=true to your geocoding requests, and then geocoding results will then come augmented with Yelp's API through the TripGo API for your API key (after at most 5 minutes). Adding \"info\" data sources Similar to TSP connectors above, you can create a \"info\" connector to enhance our platform with more information, as defined in the Info API, which allows: Reporting real-time events on a given location or area. The model follows GTFS-R standard and will be added to our platform responses accordingly. Integrating bike lanes, which will be used by our cycling results to prioritise those paths.","title":"Extensions"},{"location":"extensions/#regions","text":"","title":"Regions"},{"location":"extensions/#unlocking-regions","text":"To get results for regions with providers that aren't using Open Data please get in touch with our team by mail or on Slack (by self-invite ).","title":"Unlocking regions"},{"location":"extensions/#rio-de-janeiro-brazil","text":"Go to Fetransport Site and make sure you agree with the data terms. Contact us if you need help for this. Forward your confirmation mail to api@skedgo.com We will then unlock the region for your API key.","title":"Rio de Janeiro (Brazil) \ud83c\udf0e"},{"location":"extensions/#adding-new-regions","text":"To get results for regions that are not yet covered by the TripGo API, you as an API client can help us with the integration process to add a region of interest as follows: Collect all \"Minimum required data\" detailed below. Send the URLs where we could donwload the data from the sources to api@skedgo.com . For the cases where the data is not in a public accessible repository, please also pass on necessary contact information or access details. Wait until SkedGo processes all the information and updates the backend with the new region. This last process involves: - Configuring the region with the required data - Allocating cloud resources, including redunancy - Testing and verification of data quality and routing results - Once all tests pass, our data team will promote the new regions to our production servers For expected timing and pricing, please refer to our published price list .","title":"Adding new regions"},{"location":"extensions/#minimum-required-data","text":"Name of the country and city or area which is going to be added. Coverage: The region's coverage area where the service is going to be provided, as a polygon or bounding rectangle. The most important city or cities from that area. URL(s) to the public transport timetables for that area in a standard data format that can be be consumed by our platform. A very important rule to follow, is to include data for every major public transport operator in the coverage area. Supported data formats are: - General Transit Feed Specification (GTFS) - NeTEx - TransXChange Country/region properties that configure our routing and API responses, including: - Currency - Timezone - Default language - Preferred distance unit (metric/imperial) - Drive on left / right - Taxi cost for that area (see TSP connectors below) - Average fuel cost Road and footpath information is being consumed from OpenStreetMap , so there is no need to provide that.","title":"Minimum required data"},{"location":"extensions/#optional-data","text":"More cities to be displayed on the map: Each of them should have a default position. Public holidays information: Country default ones could be loaded from global repositories but regional or local ones could be added. Public transport real-time data, using one of the following standards: - GTFS-Realtime - Siri Car park information Transport service providers (see TSP connectors below) Traffic alerts (see \"info\" connectors below)","title":"Optional data"},{"location":"extensions/#customisations","text":"Rules for when bicycles are allowed on public transport and on which types of public transport. This is useful when this data is not provided as part of the public transport sources. Icon customisation for specific transports or services. Icon customisation for specific public transport nodes. Public transport fare calculations, see our published price list .","title":"Customisations"},{"location":"extensions/#transport-providers","text":"","title":"Transport providers"},{"location":"extensions/#unlocking-transport-modes","text":"To get results for providers who aren't using Open Data, follow the instructions for the provider below. If you want to use a provider that hasn't yet been connected to our system, please get in touch with our team by mail or on Slack (by self-invite ).","title":"Unlocking transport modes"},{"location":"extensions/#blablacar","text":"Integrations : Routing, Real-time Read the terms of use of BlaBlaCar's API and make sure you comply with them in your app. Sign up to BlaBlaCar's API . Enter your BlaBlaCar auth key in your application credentials . BlaBlaCar results will start coming through the TripGo API for your API key (after at most 5 minutes).","title":"BlaBlaCar \ud83c\udf0d"},{"location":"extensions/#goget","text":"Integrations : Locations, Routing, Real-time Get in touch with GoGet 's sales team and get access to their API. Enter your GoGet ConsumerKey and GoGet ConsumerSecret in your application credentials . GoGet results will start coming through the TripGo API for your API key (after at most 5 minutes).","title":"GoGet \ud83c\udde6\ud83c\uddfa"},{"location":"extensions/#lyft","text":"Integrations : Routing, Real-time, Bookings Read the terms of use of Lyft's API and make sure you comply with them in your app. Sign up to Lyft's API . Enter your Lyft Client ID and Lyft Client Secret in your application credentials . Lyft results will start coming through the TripGo API for your API key (after at most 5 minutes).","title":"Lyft \ud83c\uddfa\ud83c\uddf8"},{"location":"extensions/#ola","text":"Integrations : Routing, Real-time Get in touch with Ola 's sales team and get access to their API. Enter your OLA ApiKey in your application credentials . Ola results will start coming through the TripGo API for your API key (after at most 5 minutes).","title":"Ola \ud83c\uddee\ud83c\uddf3 \ud83c\udde6\ud83c\uddfa \ud83c\uddf3\ud83c\uddff \ud83c\uddec\ud83c\udde7"},{"location":"extensions/#unlocking-public-transport-real-time-data","text":"To get real-time data for providers who aren't using Open Data, follow the instructions for the provider below. If you want to use a provider that hasn't yet been connected to our system, please get in touch with our team by mail or on Slack (by self-invite ).","title":"Unlocking public transport real-time data"},{"location":"extensions/#chicagos-cta","text":"Read the terms of use of CTA's API and make sure you comply with them in your app Sign up to CTA's API Enter your CTA key for Chicago in your application credentials . Real-time data for CTA for your TripGo API key will be enabled (after at most 5 minutes).","title":"Chicago's CTA \ud83c\uddfa\ud83c\uddf8"},{"location":"extensions/#stib-mivb-in-brussels","text":"Read the terms of use of STIB-MIVB's open data platform and make sure you comply with them in your app Sign up to STIB-MIVB's API Enter your STIB-MIVB realtime api key in your application credentials . Real-time data for STIB-MIVB for your TripGo API key will be enabled (after at most 5 minutes). To get real-time data for providers who aren't using Open Data, follow the instructions for the provider below. If you want to use a provider that hasn't yet been connected to our system, please get in touch with our team by mail or on Slack (by self-invite ).","title":"STIB-MIVB in Brussels \ud83c\udf0e"},{"location":"extensions/#adding-new-providers-tsp-connectors","text":"For TSPs that are not yet integrated into our platform, you can add them by: Implementing the corresponding API according to our API specs , and then Sending the URL of where you have deployed your implementation to api@skedgo.com . The process then involves a manual step (which we plan to automate) to add that to our list of TSP connectors and enable it. It will usually take 1 day after it is added to our list for results will then include the new TSP, with some exceptions like pod based share vehicles, which will take between 3 and 7 days.","title":"Adding new providers: TSP connectors"},{"location":"extensions/#how-does-this-work","text":"All TSP connector APIs share in common three endpoints: config : the list of endpoints that are implemented, similar to gbfs.json provider : the information about the provider, which may include links to mobile apps and deep links (with a pattern); and also the list of modes for the TSP coverage : a list of coverage areas of the provider, and for each area, it is possible to define available products and pricing rules Config endpoint allows our platform to understand what are the capabilities of the TSP integration of each connector. Provider information is what our platform will use to attribute results. This will be passed on with any API responses that include results from your TSP connector. Coverage will allow our platform to know in which areas (i.e., regions) the TSP will be enabled.","title":"How does this work"},{"location":"extensions/#taxi-and-tnc","text":"For taxi and TNC providers we defined a Taxi API which allows you to: Add static pricing (in coverage endpoint), which will be shown as an estimate cost and used by our routing engine when creating trip alternatives. Provide real-time ETAs, which might differ by \"product\". Provide real-time costs estimations based on specific trip details. Enable in-app booking capabilities, so users can directly initiate the booking process through our platform.","title":"Taxi and TNC"},{"location":"extensions/#shared-bikes-scooters-and-cars","text":"For shared vehicles, such as bikes, scooters or cars, we support the GBFS standard with the addition of the shared endpoints mentioned above (except for config which is replaced by the standard gbfs.json ). This includes support for car-sharing, but be aware that this part of the standard is not finalised yet (as of February 2021). We also support GBFS sources with only one endpoint, for example just the free_bike_status.json endpoint.","title":"Shared bikes, scooters and cars"},{"location":"extensions/#additional-data-sources","text":"","title":"Additional data sources"},{"location":"extensions/#unlocking-real-time-traffic","text":"To get real-time traffic information, you need to unlock one of the providers below. If you want to use a provider that hasn't yet been connected to our system, please get in touch with our team by mail or on Slack (by self-invite ).","title":"Unlocking real-time traffic"},{"location":"extensions/#live-traffic-from-google","text":"Read the terms of use of Google Maps and make sure you comply with them in your app - in particular, that you are using a Google Map. Sign up to the Google Maps Directions API Enter your Google Maps Directions API key in your application credentials . Car results leaving now will then come augmented with Google's drive time predictions through the TripGo API for your API key (after at most 5 minutes).","title":"Live-Traffic from Google \ud83c\udf0e"},{"location":"extensions/#live-traffic-from-tomtom","text":"Sign up to the TomTom Maps API , making sure you read the terms and comply with them - in particular, that you're not affiliated with a prohibited party and that you're using a TomTom or TomTom licenses map UI (e.g., Apple Maps). Enter your TomTom consumer API key and TomTom consumer secret in your application credentials . Car results leaving now will then come augmented with TomTom's drive time predictions through the TripGo API for your API key (after at most 5 minutes).","title":"Live-Traffic from TomTom \ud83c\udf0e"},{"location":"extensions/#unlocking-geocoding-providers","text":"To get results from geocoding data for providers who aren't using Open Data when using geocoding.json endpoint, follow the instructions for the provider below. These providers will only apply for non auto-completion requests, except for What3Words ones, which can be used for both type of geocoding requests. If you want to use a provider that hasn't yet been connected to our system, please get in touch with our team by mail or on Slack (by self-invite ).","title":"Unlocking geocoding providers"},{"location":"extensions/#foursquare","text":"Read the Foursquare Terms of Use and make sure you comply with them in your app. Sign up to the Foursquare Developers Site Enter your Foursquare API key in your application credentials . Add allowFoursquare=true to your geocoding requests, and then geocoding results will then come augmented with Foursquare's API through the TripGo API for your API key (after at most 5 minutes).","title":"Foursquare \ud83c\udf0e"},{"location":"extensions/#google-places","text":"Read the Places API Policies and make sure you comply with them in your app - in particular, that you are using a Google Map. Sign up to the Google Places API Enter your Google Places API key in your application credentials . Add allowGoogle=true to your geocoding requests, and then geocoding results will then come augmented with Google Places's API through the TripGo API for your API key (after at most 5 minutes).","title":"Google Places \ud83c\udf0e"},{"location":"extensions/#what3words","text":"Read the API Licence Agreement and make sure you comply with them in your app. Sign up to the What3Words API Enter your What 3 Words key in your application credentials . Add allowW3W=true to your geocoding requests, and then geocoding results will then come augmented with What3Words's API through the TripGo API for your API key (after at most 5 minutes).","title":"What3Words \ud83c\udf0e"},{"location":"extensions/#yelp","text":"Read the Yelp Terms of Use and make sure you comply with them in your app. Sign up to the Yelp Developers Site Enter your Yelp API key in your application credentials . Add allowYelp=true to your geocoding requests, and then geocoding results will then come augmented with Yelp's API through the TripGo API for your API key (after at most 5 minutes).","title":"Yelp \ud83c\udf0e"},{"location":"extensions/#adding-info-data-sources","text":"Similar to TSP connectors above, you can create a \"info\" connector to enhance our platform with more information, as defined in the Info API, which allows: Reporting real-time events on a given location or area. The model follows GTFS-R standard and will be added to our platform responses accordingly. Integrating bike lanes, which will be used by our cycling results to prioritise those paths.","title":"Adding \"info\" data sources"},{"location":"faq/","text":"General Languages Which languages does the API support? Most text that's returned in the results and meant to be displayed to users has been localised to several languages - Chinese (simplified and traditional), Danish, Dutch, English, German, Italian, Finnish, French, Korean, Portuguese, Spanish. The translations are done in the open on Crowdin and everyone can contribute, including adding new languages. One note of caution: Some text, such as line names and status alerts, is provided by transport providers and only available in the languages provided by them. Regions What are regions? Our API splits the world into several pieces, which we call regions. Several endpoints require you to pass along a region code, e.g., because identifiers might be duplicated around the world. You can get a list of regions by quering regions.json : curl 'https://api.tripgo.com/v1/regions.json' -H 'Content-Type: application/json' --compressed -H \"X-TripGo-Key: $tripgoKey\" -d '{\"v\":2}' Then extract the polylines from there and match your coordinates to a region. This endpoint also tells you which modes are supported by routing for a given region. I noticed URLs in those regions, how can/should I use those? Most developer should not need to worry about these and can just use the api.tripgo.com domain. However, performance critical application can use this to reduce lag and directly hit the routing servers. For advanced users : This exposes to you that our API is covered by multiple servers - though not every server covers ever region. You can use the URLs to directly query servers covering a certain region \u2013 which can be beneficial to reduce lag and is recommended for server-to-server communication. However, be aware that you should add failover from one server to another yourself then, as individual servers can go down unannounced for maintenance. You should only cache this information short term as those URLs can change without notice. Health check How can I check whether the service is working? You can to that by querying our regions.json endpoint, adding the X-TripGo-HealthCheck header: curl 'https://api.tripgo.com/v1/regions.json' -H \"X-TripGo-Key: $tripgoKey\" -H \"X-TripGo-HealthCheck: true\" If the health-check passed, you'll get a 200 OK back with the following body: {\"healthCheckPassed\": true} These requests are free of charge. Map Data Which Map Data Layer do you use? Our platform uses OSM ( Open Street Map ) for the underlying map data, and this information is used when we calculate routes (mainly for private transport modes). This data affects, for example, how we decide what routes are faster, the shapes of the resulting trips for roads, paths and cycleways, among others. We can also integrate other data layers (such as Here ) upon request. If you want to use other data layer than OSM, please get in touch with our team by mail or on Slack (by self-invite ). But I see Google Maps in TripGo apps TripGo Android app and our web app use Google Maps to display information on the map, whereas the TripGo iOS app uses Apple Maps . Note, however, that this is different from the map data used by the platform to calculate routes. Google or Apple Maps are the visual map used by front-end apps to display trips and locations to the end user. It is up to the front-ends to decide which mapping UI SDK to use. It is important to note that different mapping UIs may have restrictions in their licensing terms which other APIs and services can be used to display on and alongside those maps. Routing Mode Identifiers What are all these peculiar looking strings such as pt_pub ? Syntax The syntax of the mode string is like this: <group>_<mode that makes sense to the user>[_<provider or fine-grained mode>][_<line number>] List of groups Warning : This list can expand at any time when types of transport are added to SkedGo's backend, so if you hard-code how to interpret these identifiers, make sure to handle it gracefully if the API returns an identifier that you haven't yet seen. pt_ is for transit which runs on schedules ps_ is for taxi-like on-demand services me_ is for vehicles you drive yourself cy_ is for cycling Deprecated (use me_mic_ instead) wa_ is for walking and similar (e.g., wheelchair) in_ is for intercity long distance transport stationary_ is for stationary segments in between transport segments pt_ pt_pub is \"public transit\" that is accessible to the general public pt_pub_bus pt_pub_cablecar pt_pub_carferry pt_pub_coach , long-distance buses pt_pub_expressbus pt_pub_ferry pt_pub_funicular pt_pub_gondola pt_pub_metro , similar to subway but also going overground pt_pub_monorail pt_pub_regionaltrain , e.g., inter-city trains pt_pub_subway pt_pub_train , primarily local/commuter trains pt_pub_tram pt_ltd_SCHOOLBUS is public transit of limited access (school buses) pt_ltd_SCHOOLBUS_<line number> for a specific school bus line ps_ ps_drt is for demand-responsive transport ps_drt_{provider} to enable just a specific provider ps_tax is for taxis ps_tnc is for ride-hailing (TNC is California's official code for them) ps_tnc_{provider} to enable just a specific provider, e.g., ps_tnc_lyft me_ me_car is for your own car me_car-s is for car sharing (like ZipCar or GoGet) me_car-r is for car rental (like Budget) me_car-p is for car pooling (like BlaBlaCar) me_mot is for your own motorbike me_mic is for your own micro-mobility me_mic_bic , regular _bic_ycle me_mic_fold-bic , _fold_ing/portable _bic_ycle that will be taken on any public transport mode, and will be taken all the way to the destination me_mic_e-sco , _e-sco_oter up to 25 km/h. Portable, allowed on cycle lanes in general, except specific rules in certain countries me_mic_fast-e-sco , fast _e-sco_oter up to 45 km/h. Portable, not allowed on cycle lanes in general, except specific rules in certain countries me_mic-s is for shared micro-mobility, e.g., bike-sharing or scooter-sharing stationary_ stationary_parking-onstreet is for parking a vehicle on-street stationary_parking-offstreet is for parking a vehicle in an off-street location stationary_wait is a buffer for waiting for the following transport, e.g., waiting for a taxi or ride share to show up, but not for transferring between timetable-based public transport segments which get the special identifier below. stationary_transfer is for transferring between timetable-based public transport segments, often following a walk; note: you only get this if there are at least two public transport segments in a trip. stationary_vehicle-collect is for picking up a shared vehicle stationary_vehicle-return is for returning a shared vehicle stationary_airport-checkin is for checking in at an airport stationary_airport-checkout is for \"checking out\" off an airport, e.g., for picking up luggage and going through immigration stationary_airport-transfer is for transferring between flights at an airport Single-modal vs. multi-modal routing How do I get these sweet results which combine taxis or other private transport modes with public transport? You need to specify multiple modes in the routing.json requests, e.g., by using modes=pt_pub&modes=ps_tax . You can specify a long list of modes as the API will then return suitable combinations for any of those. What if I want to get both public-transport-only results and mixed results? By default the request with multiple modes will only return inter-modal results, no results for individual modes. The preferred way is to send off separate requests, e.g., if you want public transport, taxi, and combinations of the two, you need to send three requests: one with modes=pt_pub , one with modes=ps_tax , and one with modes=pt_pub&modes=ps_tax . Alternatively, you can send the optional allModes=true with the request that has all the modes. In that case a single request is sufficient to get all the single-modal and inter-modal results, but use this with caution as by the notes below. A few things to note: It is preferred to send separate per-mode requests as some modes depend on external API calls, which slow things down. Inter-modal results are generally not as fast to calculate due to the many combinations to crunch and them being likely to depend on multiple external API calls. By having the inter-modal request not returning single-modal results, you don't need to do any duplicate detection between the results of the different calls as they are mutually exclusive. You'll only get such inter-modal combinations where that combination is better in some way than using any individual mode by itself. It is therefore quite common that inter-modal requests result in an empty response. Trips, groups, frequencies and templates What is the logic behind trip groups and what does the frequency property mean? Each group is one way of getting from A to B. Each trip in a group is taking the same modes, and similar stops and tickets. They can take different services and different platforms, but overall they are all the same way of getting where you want to go, just at different times. Frequency is related to this. It's the average frequency for how often such trips in a group run. It's an indication of how long you'd need to wait if you missed a trip in that group. In our UI, for showing alternative ways of getting from A to B, we display a list of trip groups and for each trip group we display a \"representative\" trip, which is the one that fits the query the best. That's the trip in the trip group with the lowest weightedScore . Why are segments split into references and templates? This is related to trip groups: Trips in those groups often vary in just a few components but often take the same way or share other properties. The shared properties live in the templates while the properties that typically vary between trips live in the references. This can significantly cut down the size of the results and, thus, also the parsing speed on the client. Trips results Why do I get trips that don't start or end at the requested coordinates? The routing results snap to the road/footpath network. So if your requested coordinates don't fall on a the network, the trips that you get will start/end at the nearest location of the road/footpath network. The start of a trip, depends on the available modes. If the query is for driving, they will start at nearest road that allows driving, while trips that allow walking (or cycling) will start at the nearest footpath. This means that if you request multiple different modes, the trips might start at different locations, depending on the modes used in the trip. The end of a trip will snap to the nearest footpath, i.e., driving trips might end with parking and then a walk. Why do I get trips with the first segment of a trip already in the past? When you have a trip group, you will get trips departing before the best one matching the query. What you should do is, grey it out in the UI and don't select it by default (the weighted score is a good indicator for this). Note that you can even get a trip group only with a trip in the past, e.g., if you queried for 12:15am and the last ferry left at 12:10. Why do I get trips having segments that \"go back in time\" and result in arriving after the depart of the next one? There may be cases where a segment of a trip is delayed, and due to realtime updates, the trip gets negative waiting times, e.g., a bus is delayed by 5 minutes and the trip had a connection of 2 minutes to take a train. These cases should be handled by the app, either by alerting the user, by recomputing the trip, or by any other measure you consider appropriate. Why do I get trips that don't start or end at the exact coordinates that I requested? This is expectd and intentional. Our routing engine can only route from a point on the transport network to another point on the transport network. If the requested coordinates aren't on the transport network, it looks for the closest point on the transport network to snap to and route between them. This is made explicit in the routing results which return the query inputs and also for each trip where it started and ends. This also explains why some short distance routings requests don't return anything. Information on that level might not be available, and routing starts and ends at practically at effectively the same location, resulting in nothing to return. Imagine you drop a pin in the middle of a lake. Our routing engine routes to the closest point along a footpath to that point, and the trips terminate there. Requesting a walk from there to the middle of the lake wouldn't return anything. The same applies to parks or routing to the middle of a block where there's no additional information in OpenStreetMap. You can indicate this in your UI by drawing a hop or dashed line between the requested coordinates and where the trip starts or ends. Note the fromStreetName and toStreetName input parameters which let you bias which streets our routing engine should snap to. Say, a user typed in \"15 Main St\" into your app, which your geocoding service turns into a point coordinate in the middle of a block which is actually closer to somewhere on \"2nd St\". Our route would start on \"2nd St\". If you provide \"Main St\" as the fromStreetName parameter, it'll tell our routing engine to prefer to start on nearby streets of that name, even if they aren't the closest in a straight-line distance. Placeholders in segment templates What are all the possible values for placeholders and how should they get interpreted? In order to use segment templates for multiple similar segments, the notes and action fields of a segment templates use placeholders, which should be filled it at run-time with the information from the segment template, and potentially updated with real-time data. <NUMBER> : Placeholder for the number of short name of the transit service, e.g., segment.serviceNumber . <LINE_NAME> : Placeholder for the long name of the transit service, e.g., segment.serviceName . <DIRECTION> : Placeholder for the direction of the transit service, e.g., segment.serviceDirection . <LOCATIONS> : Placeholder for the start and end location of the segment, e.g., segment.start -> segment.end . <PLATFORM> : Placeholder for the embarkation platform of the transit service, e.g., segment.platform . <STOPS> : Placeholder for the number of stops that a transit service takes from the start to the end of the segment (including the disembarkation, but excluding the embarkation stop), e.g., segment.stops . <TIME> *: Placeholder for the departure time of the segment, e.g., segment.startTime formatted as a time. Note that this can directly follow a <NUMBER> template, so you might have to add spacing. <DURATION> *: Placeholder for the total duration of the segment, e.g., segment.endTime - segment.startTime formatted as a duration string. <TRAFFIC> : (Badly named) placeholder for the total duration without traffic of the segment, e.g., segment.durationWithoutTraffic formatted as a duration string. * : Should be updated with real-time data. Advanced Routing Features How does wheelchair flag in true affect the resulting trips? There are three possible scenarios for public services, public stops, and paths: we know they are wheelchair accessible, we know they are not wheelchair accessible, or we don't have information about them. When the wheelchair flag is on, our routing engine will try to avoid services, stops and paths that are known by us to be inaccessible. In addition, we'll change 'walking' instructions to 'rolling' instructions, and indicate which sections are accessible, inaccessible or unknown. What's the action field in the alerts for? Sometimes we get real-time data that may change the accessibility status for public stops, for example when a lift is temporarily out of service in a train station. In these cases, we provide a mechanism that allows to identify the problem and send a re-route request specifically asking to avoid the stop(s) that have become inaccessible. If the embark/disembark stop of a public segment has issues, then we'll associate that segment with an alert describing the issue and containing a special action field of type rerouteExcludingStops which provides a list of the affected stop codes. Then if you want to get a new set of results avoiding those stops, you can add the avoidStops parameter to your original routing request, using the stop codes provided in the alert action field, and re-send it. Note that this new request will only avoid the stops you specifically indicated with the avoidStops parameter, so your new set of results may again include an alert for a different stop that also has issues. So you may want to send a third request asking to avoid this one too, but it's important that you include all of them in the avoidStops list, or otherwise you'll get again the stops that were first excluded. Locations Locations, cell IDs and hash codes What are the cell IDs in the locations.json endpoint? The way map regions are specified takes a bit of getting used to but it's worth it, as it allows caching results on the client, while frequently calling this endpoint to make sure the local data is update without requiring a lot of data overhead (and having most of the logic on the server). This works by splitting the world into individual cells which get an identifier which represents the south-west corner as $(lat*cellsPerDegree)#$(lng*cellsPerDegree) . Got it. And cellIDHashCodes ? You typically call locations.json with the cell IDs, but if you want to cache this information on the client, then, later, you'll want to use cellIDHashCodes as the input. Here you, again, send the cell IDs but this time with the hash codes for each cell from the previous output. You'll then only get content for cells if their content changed. Example Let's say, you want the minor stops around CBD of Sydney, Australia. You'll first request: { \"region\": \"AU_NSW_Sydney\", \"level\": 2, \"cellIDs\": [ \"-2540#11339\", \"-2540#11340\", \"-2540#11341\", \"-2541#11339\", \"-2541#11340\", \"-2541#11341\", \"-2542#11339\", \"-2542#11340\", \"-2542#11341\" ] } You'll then get results: { \"groups\": [ { \"hashCode\": 690784261, \"key\": \"-2540#11339\", \"stops\": [...] }, { \"hashCode\": -1940969928, \"key\": \"-2540#11340\", \"stops\": [...] } ] } You can then cache these and later on request again for changes by supplying cellIDHashCodes : { \"region\": \"AU_NSW_Sydney\", \"level\": 2, \"cellIDHashCodes\": { \"-2540#11339\": 690784261, \"-2540#11340\": -1940969928 } } Which will then only return any groups that have changed. If nothing changed, you'll just get back: { \"groups\": [] } Note : You can do the same thing for the major stations of level 1. In that case the cell ID is typically the code of the region itself: { \"region\": \"AU_NSW_Sydney\", \"cellIDHashCodes\": { \"AU_NSW_Sydney\": 1096794422 } }","title":"F.A.Q."},{"location":"faq/#general","text":"","title":"General"},{"location":"faq/#languages","text":"Which languages does the API support? Most text that's returned in the results and meant to be displayed to users has been localised to several languages - Chinese (simplified and traditional), Danish, Dutch, English, German, Italian, Finnish, French, Korean, Portuguese, Spanish. The translations are done in the open on Crowdin and everyone can contribute, including adding new languages. One note of caution: Some text, such as line names and status alerts, is provided by transport providers and only available in the languages provided by them.","title":"Languages"},{"location":"faq/#regions","text":"What are regions? Our API splits the world into several pieces, which we call regions. Several endpoints require you to pass along a region code, e.g., because identifiers might be duplicated around the world. You can get a list of regions by quering regions.json : curl 'https://api.tripgo.com/v1/regions.json' -H 'Content-Type: application/json' --compressed -H \"X-TripGo-Key: $tripgoKey\" -d '{\"v\":2}' Then extract the polylines from there and match your coordinates to a region. This endpoint also tells you which modes are supported by routing for a given region. I noticed URLs in those regions, how can/should I use those? Most developer should not need to worry about these and can just use the api.tripgo.com domain. However, performance critical application can use this to reduce lag and directly hit the routing servers. For advanced users : This exposes to you that our API is covered by multiple servers - though not every server covers ever region. You can use the URLs to directly query servers covering a certain region \u2013 which can be beneficial to reduce lag and is recommended for server-to-server communication. However, be aware that you should add failover from one server to another yourself then, as individual servers can go down unannounced for maintenance. You should only cache this information short term as those URLs can change without notice.","title":"Regions"},{"location":"faq/#health-check","text":"How can I check whether the service is working? You can to that by querying our regions.json endpoint, adding the X-TripGo-HealthCheck header: curl 'https://api.tripgo.com/v1/regions.json' -H \"X-TripGo-Key: $tripgoKey\" -H \"X-TripGo-HealthCheck: true\" If the health-check passed, you'll get a 200 OK back with the following body: {\"healthCheckPassed\": true} These requests are free of charge.","title":"Health check"},{"location":"faq/#map-data","text":"Which Map Data Layer do you use? Our platform uses OSM ( Open Street Map ) for the underlying map data, and this information is used when we calculate routes (mainly for private transport modes). This data affects, for example, how we decide what routes are faster, the shapes of the resulting trips for roads, paths and cycleways, among others. We can also integrate other data layers (such as Here ) upon request. If you want to use other data layer than OSM, please get in touch with our team by mail or on Slack (by self-invite ). But I see Google Maps in TripGo apps TripGo Android app and our web app use Google Maps to display information on the map, whereas the TripGo iOS app uses Apple Maps . Note, however, that this is different from the map data used by the platform to calculate routes. Google or Apple Maps are the visual map used by front-end apps to display trips and locations to the end user. It is up to the front-ends to decide which mapping UI SDK to use. It is important to note that different mapping UIs may have restrictions in their licensing terms which other APIs and services can be used to display on and alongside those maps.","title":"Map Data"},{"location":"faq/#routing","text":"","title":"Routing"},{"location":"faq/#mode-identifiers","text":"What are all these peculiar looking strings such as pt_pub ?","title":"Mode Identifiers"},{"location":"faq/#syntax","text":"The syntax of the mode string is like this: <group>_<mode that makes sense to the user>[_<provider or fine-grained mode>][_<line number>]","title":"Syntax"},{"location":"faq/#list-of-groups","text":"Warning : This list can expand at any time when types of transport are added to SkedGo's backend, so if you hard-code how to interpret these identifiers, make sure to handle it gracefully if the API returns an identifier that you haven't yet seen. pt_ is for transit which runs on schedules ps_ is for taxi-like on-demand services me_ is for vehicles you drive yourself cy_ is for cycling Deprecated (use me_mic_ instead) wa_ is for walking and similar (e.g., wheelchair) in_ is for intercity long distance transport stationary_ is for stationary segments in between transport segments","title":"List of groups"},{"location":"faq/#pt_","text":"pt_pub is \"public transit\" that is accessible to the general public pt_pub_bus pt_pub_cablecar pt_pub_carferry pt_pub_coach , long-distance buses pt_pub_expressbus pt_pub_ferry pt_pub_funicular pt_pub_gondola pt_pub_metro , similar to subway but also going overground pt_pub_monorail pt_pub_regionaltrain , e.g., inter-city trains pt_pub_subway pt_pub_train , primarily local/commuter trains pt_pub_tram pt_ltd_SCHOOLBUS is public transit of limited access (school buses) pt_ltd_SCHOOLBUS_<line number> for a specific school bus line","title":"pt_"},{"location":"faq/#ps_","text":"ps_drt is for demand-responsive transport ps_drt_{provider} to enable just a specific provider ps_tax is for taxis ps_tnc is for ride-hailing (TNC is California's official code for them) ps_tnc_{provider} to enable just a specific provider, e.g., ps_tnc_lyft","title":"ps_"},{"location":"faq/#me_","text":"me_car is for your own car me_car-s is for car sharing (like ZipCar or GoGet) me_car-r is for car rental (like Budget) me_car-p is for car pooling (like BlaBlaCar) me_mot is for your own motorbike me_mic is for your own micro-mobility me_mic_bic , regular _bic_ycle me_mic_fold-bic , _fold_ing/portable _bic_ycle that will be taken on any public transport mode, and will be taken all the way to the destination me_mic_e-sco , _e-sco_oter up to 25 km/h. Portable, allowed on cycle lanes in general, except specific rules in certain countries me_mic_fast-e-sco , fast _e-sco_oter up to 45 km/h. Portable, not allowed on cycle lanes in general, except specific rules in certain countries me_mic-s is for shared micro-mobility, e.g., bike-sharing or scooter-sharing","title":"me_"},{"location":"faq/#stationary_","text":"stationary_parking-onstreet is for parking a vehicle on-street stationary_parking-offstreet is for parking a vehicle in an off-street location stationary_wait is a buffer for waiting for the following transport, e.g., waiting for a taxi or ride share to show up, but not for transferring between timetable-based public transport segments which get the special identifier below. stationary_transfer is for transferring between timetable-based public transport segments, often following a walk; note: you only get this if there are at least two public transport segments in a trip. stationary_vehicle-collect is for picking up a shared vehicle stationary_vehicle-return is for returning a shared vehicle stationary_airport-checkin is for checking in at an airport stationary_airport-checkout is for \"checking out\" off an airport, e.g., for picking up luggage and going through immigration stationary_airport-transfer is for transferring between flights at an airport","title":"stationary_"},{"location":"faq/#single-modal-vs-multi-modal-routing","text":"How do I get these sweet results which combine taxis or other private transport modes with public transport? You need to specify multiple modes in the routing.json requests, e.g., by using modes=pt_pub&modes=ps_tax . You can specify a long list of modes as the API will then return suitable combinations for any of those. What if I want to get both public-transport-only results and mixed results? By default the request with multiple modes will only return inter-modal results, no results for individual modes. The preferred way is to send off separate requests, e.g., if you want public transport, taxi, and combinations of the two, you need to send three requests: one with modes=pt_pub , one with modes=ps_tax , and one with modes=pt_pub&modes=ps_tax . Alternatively, you can send the optional allModes=true with the request that has all the modes. In that case a single request is sufficient to get all the single-modal and inter-modal results, but use this with caution as by the notes below. A few things to note: It is preferred to send separate per-mode requests as some modes depend on external API calls, which slow things down. Inter-modal results are generally not as fast to calculate due to the many combinations to crunch and them being likely to depend on multiple external API calls. By having the inter-modal request not returning single-modal results, you don't need to do any duplicate detection between the results of the different calls as they are mutually exclusive. You'll only get such inter-modal combinations where that combination is better in some way than using any individual mode by itself. It is therefore quite common that inter-modal requests result in an empty response.","title":"Single-modal vs. multi-modal routing"},{"location":"faq/#trips-groups-frequencies-and-templates","text":"What is the logic behind trip groups and what does the frequency property mean? Each group is one way of getting from A to B. Each trip in a group is taking the same modes, and similar stops and tickets. They can take different services and different platforms, but overall they are all the same way of getting where you want to go, just at different times. Frequency is related to this. It's the average frequency for how often such trips in a group run. It's an indication of how long you'd need to wait if you missed a trip in that group. In our UI, for showing alternative ways of getting from A to B, we display a list of trip groups and for each trip group we display a \"representative\" trip, which is the one that fits the query the best. That's the trip in the trip group with the lowest weightedScore . Why are segments split into references and templates? This is related to trip groups: Trips in those groups often vary in just a few components but often take the same way or share other properties. The shared properties live in the templates while the properties that typically vary between trips live in the references. This can significantly cut down the size of the results and, thus, also the parsing speed on the client.","title":"Trips, groups, frequencies and templates"},{"location":"faq/#trips-results","text":"Why do I get trips that don't start or end at the requested coordinates? The routing results snap to the road/footpath network. So if your requested coordinates don't fall on a the network, the trips that you get will start/end at the nearest location of the road/footpath network. The start of a trip, depends on the available modes. If the query is for driving, they will start at nearest road that allows driving, while trips that allow walking (or cycling) will start at the nearest footpath. This means that if you request multiple different modes, the trips might start at different locations, depending on the modes used in the trip. The end of a trip will snap to the nearest footpath, i.e., driving trips might end with parking and then a walk. Why do I get trips with the first segment of a trip already in the past? When you have a trip group, you will get trips departing before the best one matching the query. What you should do is, grey it out in the UI and don't select it by default (the weighted score is a good indicator for this). Note that you can even get a trip group only with a trip in the past, e.g., if you queried for 12:15am and the last ferry left at 12:10. Why do I get trips having segments that \"go back in time\" and result in arriving after the depart of the next one? There may be cases where a segment of a trip is delayed, and due to realtime updates, the trip gets negative waiting times, e.g., a bus is delayed by 5 minutes and the trip had a connection of 2 minutes to take a train. These cases should be handled by the app, either by alerting the user, by recomputing the trip, or by any other measure you consider appropriate. Why do I get trips that don't start or end at the exact coordinates that I requested? This is expectd and intentional. Our routing engine can only route from a point on the transport network to another point on the transport network. If the requested coordinates aren't on the transport network, it looks for the closest point on the transport network to snap to and route between them. This is made explicit in the routing results which return the query inputs and also for each trip where it started and ends. This also explains why some short distance routings requests don't return anything. Information on that level might not be available, and routing starts and ends at practically at effectively the same location, resulting in nothing to return. Imagine you drop a pin in the middle of a lake. Our routing engine routes to the closest point along a footpath to that point, and the trips terminate there. Requesting a walk from there to the middle of the lake wouldn't return anything. The same applies to parks or routing to the middle of a block where there's no additional information in OpenStreetMap. You can indicate this in your UI by drawing a hop or dashed line between the requested coordinates and where the trip starts or ends. Note the fromStreetName and toStreetName input parameters which let you bias which streets our routing engine should snap to. Say, a user typed in \"15 Main St\" into your app, which your geocoding service turns into a point coordinate in the middle of a block which is actually closer to somewhere on \"2nd St\". Our route would start on \"2nd St\". If you provide \"Main St\" as the fromStreetName parameter, it'll tell our routing engine to prefer to start on nearby streets of that name, even if they aren't the closest in a straight-line distance.","title":"Trips results"},{"location":"faq/#placeholders-in-segment-templates","text":"What are all the possible values for placeholders and how should they get interpreted? In order to use segment templates for multiple similar segments, the notes and action fields of a segment templates use placeholders, which should be filled it at run-time with the information from the segment template, and potentially updated with real-time data. <NUMBER> : Placeholder for the number of short name of the transit service, e.g., segment.serviceNumber . <LINE_NAME> : Placeholder for the long name of the transit service, e.g., segment.serviceName . <DIRECTION> : Placeholder for the direction of the transit service, e.g., segment.serviceDirection . <LOCATIONS> : Placeholder for the start and end location of the segment, e.g., segment.start -> segment.end . <PLATFORM> : Placeholder for the embarkation platform of the transit service, e.g., segment.platform . <STOPS> : Placeholder for the number of stops that a transit service takes from the start to the end of the segment (including the disembarkation, but excluding the embarkation stop), e.g., segment.stops . <TIME> *: Placeholder for the departure time of the segment, e.g., segment.startTime formatted as a time. Note that this can directly follow a <NUMBER> template, so you might have to add spacing. <DURATION> *: Placeholder for the total duration of the segment, e.g., segment.endTime - segment.startTime formatted as a duration string. <TRAFFIC> : (Badly named) placeholder for the total duration without traffic of the segment, e.g., segment.durationWithoutTraffic formatted as a duration string. * : Should be updated with real-time data.","title":"Placeholders in segment templates"},{"location":"faq/#advanced-routing-features","text":"How does wheelchair flag in true affect the resulting trips? There are three possible scenarios for public services, public stops, and paths: we know they are wheelchair accessible, we know they are not wheelchair accessible, or we don't have information about them. When the wheelchair flag is on, our routing engine will try to avoid services, stops and paths that are known by us to be inaccessible. In addition, we'll change 'walking' instructions to 'rolling' instructions, and indicate which sections are accessible, inaccessible or unknown. What's the action field in the alerts for? Sometimes we get real-time data that may change the accessibility status for public stops, for example when a lift is temporarily out of service in a train station. In these cases, we provide a mechanism that allows to identify the problem and send a re-route request specifically asking to avoid the stop(s) that have become inaccessible. If the embark/disembark stop of a public segment has issues, then we'll associate that segment with an alert describing the issue and containing a special action field of type rerouteExcludingStops which provides a list of the affected stop codes. Then if you want to get a new set of results avoiding those stops, you can add the avoidStops parameter to your original routing request, using the stop codes provided in the alert action field, and re-send it. Note that this new request will only avoid the stops you specifically indicated with the avoidStops parameter, so your new set of results may again include an alert for a different stop that also has issues. So you may want to send a third request asking to avoid this one too, but it's important that you include all of them in the avoidStops list, or otherwise you'll get again the stops that were first excluded.","title":"Advanced Routing Features"},{"location":"faq/#locations","text":"","title":"Locations"},{"location":"faq/#locations-cell-ids-and-hash-codes","text":"What are the cell IDs in the locations.json endpoint? The way map regions are specified takes a bit of getting used to but it's worth it, as it allows caching results on the client, while frequently calling this endpoint to make sure the local data is update without requiring a lot of data overhead (and having most of the logic on the server). This works by splitting the world into individual cells which get an identifier which represents the south-west corner as $(lat*cellsPerDegree)#$(lng*cellsPerDegree) . Got it. And cellIDHashCodes ? You typically call locations.json with the cell IDs, but if you want to cache this information on the client, then, later, you'll want to use cellIDHashCodes as the input. Here you, again, send the cell IDs but this time with the hash codes for each cell from the previous output. You'll then only get content for cells if their content changed.","title":"Locations, cell IDs and hash codes"},{"location":"faq/#example","text":"Let's say, you want the minor stops around CBD of Sydney, Australia. You'll first request: { \"region\": \"AU_NSW_Sydney\", \"level\": 2, \"cellIDs\": [ \"-2540#11339\", \"-2540#11340\", \"-2540#11341\", \"-2541#11339\", \"-2541#11340\", \"-2541#11341\", \"-2542#11339\", \"-2542#11340\", \"-2542#11341\" ] } You'll then get results: { \"groups\": [ { \"hashCode\": 690784261, \"key\": \"-2540#11339\", \"stops\": [...] }, { \"hashCode\": -1940969928, \"key\": \"-2540#11340\", \"stops\": [...] } ] } You can then cache these and later on request again for changes by supplying cellIDHashCodes : { \"region\": \"AU_NSW_Sydney\", \"level\": 2, \"cellIDHashCodes\": { \"-2540#11339\": 690784261, \"-2540#11340\": -1940969928 } } Which will then only return any groups that have changed. If nothing changed, you'll just get back: { \"groups\": [] } Note : You can do the same thing for the major stations of level 1. In that case the cell ID is typically the code of the region itself: { \"region\": \"AU_NSW_Sydney\", \"cellIDHashCodes\": { \"AU_NSW_Sydney\": 1096794422 } }","title":"Example"},{"location":"enterprise/bookings-api/","text":"Overview Note: Enterprise customers-only Note: Beta-only The TripGo API allows making bookings for a handful of transport service providers (TSPs). This enables your users to: Link their TSP accounts and keep credentials either stored on the client or server-side. Get a list of available TSP products for a trip. Book a specific TSP product for a single segment. Update the trip with the details of the booked TSP product. Update the trip with real-time data specific to that booking. Coming soon: Book a complete trip consisting of multiple products from multiple TSPs. In order to enable bookings for your TripGo API key, please get in touch with our team . For most TSPs, you will need to provide us with additional information of your API credentials. API Endpoints Linking and unlinking accounts Before you can do any bookings, you will need to provide the relevant authentication details to the server. If the user has an account (as per the userToken header), then this is only necessary once. If the user does not have an account, this is necessary for each session. Typically, the endpoints which do the bookings will tell you, if the session hasn't been authenticated yet. auth/{region}?mode={mode} : Endpoint to get the available providers for a specific region, with the information to signin/logout if a userToken is provided in the headers. If mode is provided, only information for that mode is returned. auth/{provider}/signin : Endpoint to link an account for the specified provider. auth/{provider}/logout : Endpoint to unlink an account for the specified provider. Auth Flow This flow will depend on the TSP and can be started in two separate ways: When linking accounts to a user. When doing a booking for that particular TSP and the user has no account already linked. This flow will use the Auth Forms to provide the apps the information to show to the user and also the information required to be POSTed to continue the flow. For a TSP that allows OAuth2, the Auth Form will include the fields with the information for the apps to do OAuth, including clientId , clientSecret , scope , authUrl , tokenUrl ; and also the required field to be POSTed, including accessToken , refreshToken and expiration . For a TSP that provides a different authentication method, the AuthForm will include the required field to be filled by the user and also any extra information that need to be shown to the user in the same field format. This will follow the same flow approach as for Form-based Booking Flow . The end of this flow will depending on how it was started. If was started to link an account, the flow will end with an empty 204 response, when successfuly linked. If it was started in a booking flow, the flow will automatically continue with it, attempting to do the booking and returning the status, as in step 4 of Form-based Booking Flow . Getting available TSP for a trip If there are available TSPs for a trip segment, this will be indicated by the presence of the booking object in the segment. The booking object in the segment may include: a quickBookingUrl , indicating that the quick booking flow is available. Booking a segment Getting available TSP products for a trip If quick booking flow is available for a segment, the available TSP products can be browsed for it without providing any authentication details. As part of the quick booking flow, the quickBookingUrl will then return a list of available TSP products, which notably each come: tripUpdateURL : A URL for fetching the trip, updated for this TSP product. bookingURL : A URL for initiating the booking flow for this TSP product (step 2 of form-based booking flow ) title subtitle bookingTitle priceString price USDPrice surgeString surgeImageURL ETA imageURL Updating trip with booking details At the end of the booking flow, you will get a refreshURLForSourceObject . Hit this URL with a GET request, to get the updated trip. Note that these trips can be eligible for real-time updates even if the original trip was not eligible as there might now be additional real-time information based on the booking. Trips with a confirmed booking will also have extra information about the confirmed booking in a field called confirmation in the booking field of the segment. This confirmation object may include detailed information about the provider , vehicle and status for the booking, with the following possible fields: a title a subtitle a valueUrl a value And also a list of possible actions depending on the status of the booking, with the following fields: a title a boolean isDestructive , indicating whether this action will cancel the booking. a internalUrl indicating the action of the url is a call to the same server and will return a bookingForm . a externalUrl indicating that the action must be handled by the app accordingly. Examples of actions with internalUrl fields are cancel booking , which will have the isDestructive field in true, and rate booking . Examples of actions with externalUrl fields are qrcode values, for showing a ticket to the user, and phone numbers, starting with tel: . Rating and Tipping Whenever available, the confirmation information will include the rate booking action, which will include an internalUrl which will return the following fields: rate , an int value with min and max accepted values. feedback , a string to send an appropriate msg. tip , an int value indicating the amount to be paid as tip, in local currency.","title":"Bookings"},{"location":"enterprise/bookings-api/#overview","text":"Note: Enterprise customers-only Note: Beta-only The TripGo API allows making bookings for a handful of transport service providers (TSPs). This enables your users to: Link their TSP accounts and keep credentials either stored on the client or server-side. Get a list of available TSP products for a trip. Book a specific TSP product for a single segment. Update the trip with the details of the booked TSP product. Update the trip with real-time data specific to that booking. Coming soon: Book a complete trip consisting of multiple products from multiple TSPs. In order to enable bookings for your TripGo API key, please get in touch with our team . For most TSPs, you will need to provide us with additional information of your API credentials.","title":"Overview"},{"location":"enterprise/bookings-api/#api-endpoints","text":"","title":"API Endpoints"},{"location":"enterprise/bookings-api/#linking-and-unlinking-accounts","text":"Before you can do any bookings, you will need to provide the relevant authentication details to the server. If the user has an account (as per the userToken header), then this is only necessary once. If the user does not have an account, this is necessary for each session. Typically, the endpoints which do the bookings will tell you, if the session hasn't been authenticated yet. auth/{region}?mode={mode} : Endpoint to get the available providers for a specific region, with the information to signin/logout if a userToken is provided in the headers. If mode is provided, only information for that mode is returned. auth/{provider}/signin : Endpoint to link an account for the specified provider. auth/{provider}/logout : Endpoint to unlink an account for the specified provider.","title":"Linking and unlinking accounts"},{"location":"enterprise/bookings-api/#auth-flow","text":"This flow will depend on the TSP and can be started in two separate ways: When linking accounts to a user. When doing a booking for that particular TSP and the user has no account already linked. This flow will use the Auth Forms to provide the apps the information to show to the user and also the information required to be POSTed to continue the flow. For a TSP that allows OAuth2, the Auth Form will include the fields with the information for the apps to do OAuth, including clientId , clientSecret , scope , authUrl , tokenUrl ; and also the required field to be POSTed, including accessToken , refreshToken and expiration . For a TSP that provides a different authentication method, the AuthForm will include the required field to be filled by the user and also any extra information that need to be shown to the user in the same field format. This will follow the same flow approach as for Form-based Booking Flow . The end of this flow will depending on how it was started. If was started to link an account, the flow will end with an empty 204 response, when successfuly linked. If it was started in a booking flow, the flow will automatically continue with it, attempting to do the booking and returning the status, as in step 4 of Form-based Booking Flow .","title":"Auth Flow"},{"location":"enterprise/bookings-api/#getting-available-tsp-for-a-trip","text":"If there are available TSPs for a trip segment, this will be indicated by the presence of the booking object in the segment. The booking object in the segment may include: a quickBookingUrl , indicating that the quick booking flow is available.","title":"Getting available TSP for a trip"},{"location":"enterprise/bookings-api/#booking-a-segment","text":"Getting available TSP products for a trip If quick booking flow is available for a segment, the available TSP products can be browsed for it without providing any authentication details. As part of the quick booking flow, the quickBookingUrl will then return a list of available TSP products, which notably each come: tripUpdateURL : A URL for fetching the trip, updated for this TSP product. bookingURL : A URL for initiating the booking flow for this TSP product (step 2 of form-based booking flow ) title subtitle bookingTitle priceString price USDPrice surgeString surgeImageURL ETA imageURL","title":"Booking a segment"},{"location":"enterprise/bookings-api/#updating-trip-with-booking-details","text":"At the end of the booking flow, you will get a refreshURLForSourceObject . Hit this URL with a GET request, to get the updated trip. Note that these trips can be eligible for real-time updates even if the original trip was not eligible as there might now be additional real-time information based on the booking. Trips with a confirmed booking will also have extra information about the confirmed booking in a field called confirmation in the booking field of the segment. This confirmation object may include detailed information about the provider , vehicle and status for the booking, with the following possible fields: a title a subtitle a valueUrl a value And also a list of possible actions depending on the status of the booking, with the following fields: a title a boolean isDestructive , indicating whether this action will cancel the booking. a internalUrl indicating the action of the url is a call to the same server and will return a bookingForm . a externalUrl indicating that the action must be handled by the app accordingly. Examples of actions with internalUrl fields are cancel booking , which will have the isDestructive field in true, and rate booking . Examples of actions with externalUrl fields are qrcode values, for showing a ticket to the user, and phone numbers, starting with tel: .","title":"Updating trip with booking details"},{"location":"enterprise/bookings-api/#rating-and-tipping","text":"Whenever available, the confirmation information will include the rate booking action, which will include an internalUrl which will return the following fields: rate , an int value with min and max accepted values. feedback , a string to send an appropriate msg. tip , an int value indicating the amount to be paid as tip, in local currency.","title":"Rating and Tipping"},{"location":"enterprise/push/","text":"Push Notifications Note: Enterprise customers-only We support Push Notifications for both Android (using Firebase ) and iOS (using APN ) devices. In order to enable and use Push Notifications, the following steps are required: Register (only once) in SkedGo backend the corresponding credentials/certificates for each platform (See sections below for details). Each app instance should register itself in the corresponding platform and save the obtained token in SkedGo database, using data/user/push endpoint. To send PN to your user, you need to know the user ID on our database and use data/push endpoint, which is filtered by IP address (check with us whether your IP address is whitelisted). Android You need to create your own project in Firebase and send to us the Server Key in your project settings > cloud messaging tab. For instructions on how to implement Push Notifications in Android, go to Firebase Cloud Messaging . In short, your app needs to register into FCM to get a token and save it into our database for later usage (see data/user/push endpoint). Note that this token may change, any time that happens you need to save it again in the database. iOS You need to configure your app for APN, follow instructions from Apple or use fastlane , and then send us both the P12 file, containing the Apple Push Notification Authentication Key , and the password to unlock it. For instructions on how to implement Push Notifications in iOS, go to Configuring Remote Notification . In short, your app needs to register into APN to get a token and save it into our database for later usage (see data/user/push endpoint). Note that this token may change, any time that happens you need to save it again in the database. The token returned by the iOS SDK will be a binary data object, while our backend expends a string. To turn the data into a string, use this snipped: let tokenString = tokenData.reduce(into: \"\") { $0.append(String(format: \"%02X\", $1)) } When receiving push notifications, additional fields that were provide in the data part when sending the notification, will be accessible to your app via the userInfo that's attached to the content of the notification. The clickAction will end up in the notification's content's categoryIdentifier . Sending PN If you want to send PN to your users, you first need to have your server/s IP/s address/es whitelisted in our platform. Then, you can use data/push endpoint to send notifications to a list of users (by their userID). Notifications that we send support a title, message, sound and badge, with a ttl (time to live) value, as well as custom data which will be passed on to your apps. Be mindful of size limits imposed by Firebase or APN.","title":"Push Notifications"},{"location":"enterprise/push/#push-notifications","text":"Note: Enterprise customers-only We support Push Notifications for both Android (using Firebase ) and iOS (using APN ) devices. In order to enable and use Push Notifications, the following steps are required: Register (only once) in SkedGo backend the corresponding credentials/certificates for each platform (See sections below for details). Each app instance should register itself in the corresponding platform and save the obtained token in SkedGo database, using data/user/push endpoint. To send PN to your user, you need to know the user ID on our database and use data/push endpoint, which is filtered by IP address (check with us whether your IP address is whitelisted).","title":"Push Notifications"},{"location":"enterprise/push/#android","text":"You need to create your own project in Firebase and send to us the Server Key in your project settings > cloud messaging tab. For instructions on how to implement Push Notifications in Android, go to Firebase Cloud Messaging . In short, your app needs to register into FCM to get a token and save it into our database for later usage (see data/user/push endpoint). Note that this token may change, any time that happens you need to save it again in the database.","title":"Android"},{"location":"enterprise/push/#ios","text":"You need to configure your app for APN, follow instructions from Apple or use fastlane , and then send us both the P12 file, containing the Apple Push Notification Authentication Key , and the password to unlock it. For instructions on how to implement Push Notifications in iOS, go to Configuring Remote Notification . In short, your app needs to register into APN to get a token and save it into our database for later usage (see data/user/push endpoint). Note that this token may change, any time that happens you need to save it again in the database. The token returned by the iOS SDK will be a binary data object, while our backend expends a string. To turn the data into a string, use this snipped: let tokenString = tokenData.reduce(into: \"\") { $0.append(String(format: \"%02X\", $1)) } When receiving push notifications, additional fields that were provide in the data part when sending the notification, will be accessible to your app via the userInfo that's attached to the content of the notification. The clickAction will end up in the notification's content's categoryIdentifier .","title":"iOS"},{"location":"enterprise/push/#sending-pn","text":"If you want to send PN to your users, you first need to have your server/s IP/s address/es whitelisted in our platform. Then, you can use data/push endpoint to send notifications to a list of users (by their userID). Notifications that we send support a title, message, sound and badge, with a ttl (time to live) value, as well as custom data which will be passed on to your apps. Be mindful of size limits imposed by Firebase or APN.","title":"Sending PN"},{"location":"enterprise/tripurls/","text":"Trips URLs This feature needs to be enabled on 3scale, setting \"Keep Trips\" value on true (it is disabled by default). Whenever a trip is computed, it will be returned with a list of URLs, including: temporaryURL : Temporary URL used to retried the trip, which can be used for short-term sharing. saveURL : Temporary URL used to make the trip persistent. updateURL : Optional temporary URL used to update the trip with real-time data. hookURL (beta): Optional temporary URL used to hook the trip with real-time updates. progressURL : Optional temporary URL used to report progress updates for the trip. plannedURL : Optional temporary URL used for analytics. logURL (beta): Optional temporary URL used to log the trip in the user account. shareURL : Optional persistent of this trip URL, which can be used for sharing trips (web access only) appURL : Optional persistent of this trip URL, which can be used retrieving them long term (json access only). Trip access The temporaryURL allows access to the trip for a short-term period (maximum of 7 days from the time of creation), while our platform keeps the trip in the server that computed it originally. If you want a trip to persist forever, you can use the saveURL to save it in permanent storage (requires AWS DynamoDB connection). Saving the trip will create a new unique ID, along with two new urls: shareURL for web access and appURL for app/json access. Analytics The plannedURL is meant to be used for analytics purposes, to keep track, from the returned trips, which of them the user actually took, if that is possible to determine or guess at a client/app level. The progressURL goals is to enable apps to report user progress on a specific trip, also for analytics purposes. Save trip It's available for all trips. saveURL makes sure that a trip will be accessible at a later time, beyond what would be a typical user session. Otherwise our API makes no guarantee that a trip calculated is still available later. It is important to mention that the trip saved could change when reconstructing it from our database if there's newer real-time data available. Real-time updates Its optional as not all trips would ever get real-time data updates. If our platforms has real-time information that can be used to update a computed trip, both updateURL and hookURL will be present in the response. Both support the same goal of updating the trip with real-time information, one by pulling and the other by pushing. updateURL Allows providing a hash code so that it'll only return trip details if anything about the trip has changed since you last fetched it. This is so that apps can frequently hit that endpoint and only need to parse the response if there's any changes to the trip. See documentation Pulling for changes The updateURL can be used to pull our servers for changes in the trip. This url is meant to be used by the apps to get an updated version of the trip. This endpoint will return an empty response if there is no change, otherwise, it will return the trip in the requested format. As an example, if a service is delayed, the trip will be updated to reflect that change. Also, if the trip involves a booking to a TSP, like Uber for example, it will be getting updates of the status of the ride, as soon as those are available from the external API. The expected flow in this case is the following one: A trip is computed and our platform has sources of information for real-time updates for it, and therefore, the updateURL is returned. The client checks whether the trip has been updated with real-time changes by doing a GET to the updateURL . If the trip has been updated, the new updateURL should be used from now on. After two hours of not getting any update, the trip is discarded from memory. For more details, check our docs Receiving notifications The hookURL can be used to register a callback or web-hook, and our platform will then inform if any change in that trip occurs by POSTing to the registered url the tripID along with the tripURL for the client to retrieve the updated trip. The expected flow in this case is the following one: A trip is computed and our platform has sources of information for real-time updates for it, and therefore, the hookURL is returned. The client that wants to receive notifications about real-time changes does a POST to the hookURL ( docs ) send the webhook as url and any required header (starting with x- ) as body of the request and obtains a 204 response. At any given time the trip is updated with any real-time change, our platform does a POST to the registered web-hook. After two hours of not getting any update, the trip is discarded from memory and won't receive any more updates. The client can also remove a web-hook, by doing a DELETE request to hookURL ( docs ), and can also get the status of the hook (to confirm whether there is a hook already registered), by doing a GET to hookURL ( docs ). Note that only one web-hook per trip can be registered, and multiple calls to hookURL to register different web-hooks will override existing ones.","title":"Trip URLs"},{"location":"enterprise/tripurls/#trips-urls","text":"This feature needs to be enabled on 3scale, setting \"Keep Trips\" value on true (it is disabled by default). Whenever a trip is computed, it will be returned with a list of URLs, including: temporaryURL : Temporary URL used to retried the trip, which can be used for short-term sharing. saveURL : Temporary URL used to make the trip persistent. updateURL : Optional temporary URL used to update the trip with real-time data. hookURL (beta): Optional temporary URL used to hook the trip with real-time updates. progressURL : Optional temporary URL used to report progress updates for the trip. plannedURL : Optional temporary URL used for analytics. logURL (beta): Optional temporary URL used to log the trip in the user account. shareURL : Optional persistent of this trip URL, which can be used for sharing trips (web access only) appURL : Optional persistent of this trip URL, which can be used retrieving them long term (json access only).","title":"Trips URLs"},{"location":"enterprise/tripurls/#trip-access","text":"The temporaryURL allows access to the trip for a short-term period (maximum of 7 days from the time of creation), while our platform keeps the trip in the server that computed it originally. If you want a trip to persist forever, you can use the saveURL to save it in permanent storage (requires AWS DynamoDB connection). Saving the trip will create a new unique ID, along with two new urls: shareURL for web access and appURL for app/json access.","title":"Trip access"},{"location":"enterprise/tripurls/#analytics","text":"The plannedURL is meant to be used for analytics purposes, to keep track, from the returned trips, which of them the user actually took, if that is possible to determine or guess at a client/app level. The progressURL goals is to enable apps to report user progress on a specific trip, also for analytics purposes.","title":"Analytics"},{"location":"enterprise/tripurls/#save-trip","text":"It's available for all trips. saveURL makes sure that a trip will be accessible at a later time, beyond what would be a typical user session. Otherwise our API makes no guarantee that a trip calculated is still available later. It is important to mention that the trip saved could change when reconstructing it from our database if there's newer real-time data available.","title":"Save trip"},{"location":"enterprise/tripurls/#real-time-updates","text":"Its optional as not all trips would ever get real-time data updates. If our platforms has real-time information that can be used to update a computed trip, both updateURL and hookURL will be present in the response. Both support the same goal of updating the trip with real-time information, one by pulling and the other by pushing. updateURL Allows providing a hash code so that it'll only return trip details if anything about the trip has changed since you last fetched it. This is so that apps can frequently hit that endpoint and only need to parse the response if there's any changes to the trip. See documentation","title":"Real-time updates"},{"location":"enterprise/tripurls/#pulling-for-changes","text":"The updateURL can be used to pull our servers for changes in the trip. This url is meant to be used by the apps to get an updated version of the trip. This endpoint will return an empty response if there is no change, otherwise, it will return the trip in the requested format. As an example, if a service is delayed, the trip will be updated to reflect that change. Also, if the trip involves a booking to a TSP, like Uber for example, it will be getting updates of the status of the ride, as soon as those are available from the external API. The expected flow in this case is the following one: A trip is computed and our platform has sources of information for real-time updates for it, and therefore, the updateURL is returned. The client checks whether the trip has been updated with real-time changes by doing a GET to the updateURL . If the trip has been updated, the new updateURL should be used from now on. After two hours of not getting any update, the trip is discarded from memory. For more details, check our docs","title":"Pulling for changes"},{"location":"enterprise/tripurls/#receiving-notifications","text":"The hookURL can be used to register a callback or web-hook, and our platform will then inform if any change in that trip occurs by POSTing to the registered url the tripID along with the tripURL for the client to retrieve the updated trip. The expected flow in this case is the following one: A trip is computed and our platform has sources of information for real-time updates for it, and therefore, the hookURL is returned. The client that wants to receive notifications about real-time changes does a POST to the hookURL ( docs ) send the webhook as url and any required header (starting with x- ) as body of the request and obtains a 204 response. At any given time the trip is updated with any real-time change, our platform does a POST to the registered web-hook. After two hours of not getting any update, the trip is discarded from memory and won't receive any more updates. The client can also remove a web-hook, by doing a DELETE request to hookURL ( docs ), and can also get the status of the hook (to confirm whether there is a hook already registered), by doing a GET to hookURL ( docs ). Note that only one web-hook per trip can be registered, and multiple calls to hookURL to register different web-hooks will override existing ones.","title":"Receiving notifications"},{"location":"guides/deep-links/","text":"Deep Linking For a light-weight alternative to using our API, you can also deep-link into the TripGo app. Routing results $schema://$host/go?$parameters Opens the routing results for the specified destination, and optionally the start and time: flat , flng : Start coordinates. If not specified, the user's current location is used. tlat , tlng : End coordinates. Required, unless tname is provided. tname : Destination as a search string (supports what3words ). Required, unless tlat and tlng are provided. type : 0 for leaving ASAP, 1 for leaving after time , 2 for arriving by time . Required. time : Query time in seconds since 1970. Required, unless type is set to 0 . Examples: iOS: tripgo:///go?tname=dragon.letter.spoke Web: http://tripgo.com/go?tname=dragon.letter.spoke Destination information $schema://$host/meet?$parameters Opens the search screen with the destination and arrival time filled in. lat , lng : Coordinate where to meet. Required, unless name is provided. name : Destination as a search string (supports what3words ). Required, unless lat and lng are provided. time : Arrival time in seconds since 1970. Required. Examples: iOS: tripgo:///meet?lat=-33.94501&lng=151.25807&at=1385535734 Web: http://tripgo.com/meet?lat=-33.94501&lng=151.25807&at=1385535734 Timetable $schema://$host/stop/$region/$stopCode Opens the departures timetable for a given stop. $region and $stop use region codes and stop codes as defined in our API. Examples: iOS: tripgo:///stop/AU_NSW_Sydney/2035143 Web: http://tripgo.com/stop/AU_NSW_Sydney/2035143","title":"Deep Linking"},{"location":"guides/deep-links/#deep-linking","text":"For a light-weight alternative to using our API, you can also deep-link into the TripGo app.","title":"Deep Linking"},{"location":"guides/deep-links/#routing-results","text":"$schema://$host/go?$parameters Opens the routing results for the specified destination, and optionally the start and time: flat , flng : Start coordinates. If not specified, the user's current location is used. tlat , tlng : End coordinates. Required, unless tname is provided. tname : Destination as a search string (supports what3words ). Required, unless tlat and tlng are provided. type : 0 for leaving ASAP, 1 for leaving after time , 2 for arriving by time . Required. time : Query time in seconds since 1970. Required, unless type is set to 0 . Examples: iOS: tripgo:///go?tname=dragon.letter.spoke Web: http://tripgo.com/go?tname=dragon.letter.spoke","title":"Routing results"},{"location":"guides/deep-links/#destination-information","text":"$schema://$host/meet?$parameters Opens the search screen with the destination and arrival time filled in. lat , lng : Coordinate where to meet. Required, unless name is provided. name : Destination as a search string (supports what3words ). Required, unless lat and lng are provided. time : Arrival time in seconds since 1970. Required. Examples: iOS: tripgo:///meet?lat=-33.94501&lng=151.25807&at=1385535734 Web: http://tripgo.com/meet?lat=-33.94501&lng=151.25807&at=1385535734","title":"Destination information"},{"location":"guides/deep-links/#timetable","text":"$schema://$host/stop/$region/$stopCode Opens the departures timetable for a given stop. $region and $stop use region codes and stop codes as defined in our API. Examples: iOS: tripgo:///stop/AU_NSW_Sydney/2035143 Web: http://tripgo.com/stop/AU_NSW_Sydney/2035143","title":"Timetable"},{"location":"guides/sdks/","text":"","title":"Sdks"}]}